ArrayList<Integer> vector<int>
int[] int a[]
int* &varable class 


#HashSet<Integer> unordered_set<int>
HashMap<Integer,Integer> unordered_map<int>


# sort
- java
Arrays.sort
Collections.sort
- 迭代器

sort(arr.begin()+1, arr.end(), [](auto & a, auto & b) {
	return a > b;//这个是less函数
	});

数组就用指针当迭代器

# 引用/参数经常使用
## const type & 
仅在优先级队列的仿函数使用

## auto&
用在匿名函数排序和迭代器for中

## 传递的容器参数一定要用引用卧槽
4.0
void dfs(vector<int>& qian, vector<int>& hou, int lh, int rh, vector<int>& zhong, int lz, int rz) {
  
}

# math.h
pow()


# vector<>
- java ArrayList<Integer>
- 和go的silce一样
vector<int> arr(n,0) 相当于已经插入了n个0注意!!!
vector<Edge> edges(m);
    for (int i = 0; i < m; ++i)
        cin >> edges[i].u >> edges[i].v >> edges[i].w;
- erase 迭代器

# 队列/栈
- java
ArrayDeque<Integer>
- c++直接queue<int> container; stack<int> container ; deque<int> container

# 优先级队列PriorityQueue<integer>
struct cmp {
	bool operator()(const int& a, const int& b) {
		return a > b;//小根堆这是bool类型的cmp函数
	}
};
priority_queue<int, vector<int>, cmp> cache;


# string
stoi to_string



# map set
- comma ok
if (set.find(num) != set.end())
map同理if(map.find(num)!=map.end())
找不到就会返回迭代器末端
用pair tuple不用考虑hashcode问题

# struct
- java
```java
public class zuobiao{
	int x;
	int y;
	zuobiao(){};
	zuobiao(int x_,int y_){
		x=x_;
		y=y_;
	}
}
```
- c++
和java完全一样
```cpp
struct zuobiao{
	int x;
	int y;
	zuobiao(){};
	zuobiao(int x_,int y_){
		x=x_;
		y=y_;
	}
}
```
# 拷贝
- java
new(arraylist<>) 
- c++直接 赋值就是深拷贝  queue<>=queue<>

# io
getline(cin,str) 读入一行
while (std::cin >> num)  
# 奇技淫巧
- #define int long long 搭配 signed
- cin.tie(nullptr);
ios::sync_with_stdio(false);// 解绑后不要再混用 printf 和 cin 
可以cin<<num<<":"  这种组合
- #include <bits/stdc++.h>
- const int INF = 0x3f3f3f3f;const int MOD = 1e9 + 7;
这个是1*10^9大约 且两个相加不超过int最大值
# 题目

## 1.2 2.0 
- 4.4 
- 4.1 
- 4.2 这个树有up 两个mp直接向上移动就行
- 6.3 要考虑不连通 操蛋连通树求解

## 7.4
- floyd
```cpp
#include <queue>
#include <iostream>
#include <algorithm>
#include <vector> // 【修正：必须包含】
#include <math.h>

using namespace std;

const int INF = 0x3f3f3f3f; // 习惯用 INF 替代 INT 避免重名



void floyd(vector<vector<int>>& mat,int n) {
    for (int k = 1; k < n+1; k++)
    {
        for (int  i = 1; i < n+1; i++)
        {
            for (int  j = 1; j < n+1; j++)
            {
                int tmp = mat[i][k] + mat[k][j];
                if (tmp < mat[i][j]) {
                    mat[i][j] = tmp;
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //
    int n, m; cin >> n >> m;
    vector<vector<int>> mat(n + 1, vector<int>(n + 1, INF));
    for (int i = 1; i <= n; i++) {
        mat[i][i] = 0;
    }
    for (int i = 0; i < m; i++) {
        int from, to, wei; cin >> from >> to >> wei;
        mat[from][to] = wei;
        mat[to][from] = wei;
    }
    floyd(mat, n);
    bool zhaodao = false;
    int dongwu = 0;
    int dongwumax = INF;
    for (int i = 1; i <= n; i++) {
        int maxw = 0;
        for (int j = 1; j <= n; j++) {
            if (mat[i][j] == INF) {
                goto loop;
            }
            maxw = max(maxw, mat[i][j]);
        }
        zhaodao = true;
        if (dongwumax > maxw) {
            dongwumax = maxw;
            dongwu = i;
        }

    loop:
        continue;
    }
    if (zhaodao) {
        cout << dongwu << " " << dongwumax;
    }
    else {
        cout << 0;
    }

    //
}
```
## 7.1 经典dj
```cpp
#include <queue>
#include <iostream>
#include <algorithm>
#include <vector> // 【修正：必须包含】
#include <math.h>

using namespace std;

const int INF = 0x3f3f3f3f; // 习惯用 INF 替代 INT 避免重名

struct edge {
    int to;
    int distance;
    int cost;
    edge() {};
    edge(int t, int d, int c) : to(t), distance(d), cost(c) {}
};

struct node {
    int v;
    int distance;
    int cost;
    node() {};
    node(int v_, int d, int c) : v(v_), distance(d), cost(c) {}
};

struct cmp {
    bool operator()(const node& a, const node& b) {
        if (a.distance != b.distance) {
            return a.distance > b.distance;
        }
        return a.cost > b.cost;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, s, d;
    if (!(cin >> n >> m >> s >> d)) return 0;

    vector<vector<edge>> graph(n);
    for (int i = 0; i < m; i++) {
        int from, to, distance, cost;
        cin >> from >> to >> distance >> cost;
        graph[from].push_back(edge(to, distance, cost));
        graph[to].push_back(edge(from, distance, cost));
    }

    priority_queue<node, vector<node>, cmp> buffer;
    vector<int> dist(n, INF);
    vector<int> cost(n, INF);
    vector<bool> S(n, false);

    dist[s] = 0;
    cost[s] = 0;
    buffer.push(node(s, 0, 0));

    while (!buffer.empty()) {
        node top = buffer.top();
        buffer.pop();

        int u = top.v;
        if (S[u]) continue;
        
        // 【修正：简单的退出判断】
        if (u == d) {
            S[u] = true;
            break;
        }
        
        S[u] = true;

        for (auto& e : graph[u]) {
            // 这里不需要判断 if (S[e.to]) continue; 
            // 因为 Dijkstra 允许通过已确定节点来观察，只是不会更新它们
            
            int willd = dist[u] + e.distance;
            int willc = cost[u] + e.cost;

            if (willd < dist[e.to]) {
                dist[e.to] = willd;
                cost[e.to] = willc;
                buffer.push(node(e.to, willd, willc));
            } 
            else if (willd == dist[e.to]) {
                // 【修正：比较的是总费用 willc 和 cost[e.to]】
                if (willc < cost[e.to]) {
                    cost[e.to] = willc;
                    buffer.push(node(e.to, willd, willc));
                }
            }
        }
    }

    cout << dist[d] << " " << cost[d];
    return 0;
}
```

## 7.3
```cpp
#include <queue>
#include <iostream>
#include <algorithm>
#include <vector> // 【修正：必须包含】
#include <math.h>

using namespace std;

const int INF = 0x3f3f3f3f; // 习惯用 INF 替代 INT 避免重名

struct vertex {
    int to;
    int weight;
    vertex() {};
    vertex(int t, int w) {
        to = t;
        weight = w;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //
    int n, m; cin >> n >> m;
    vector<vector<vertex>> graph(n, vector<vertex>(0));
    vector<int> degree(n,0);
    for (int i = 0; i < m; i++) {
        int from, to, weight; cin >> from >> to >> weight;
       vertex tmp(to, weight);
       graph[from].push_back(tmp);
       degree[to]++;
    }
    int vnum = 0;
    int ans = 0;
    queue<int> buffer;
    vector<int> time(n, 0);
    for (int i = 0; i < n; i++) {
        if (degree[i] == 0) {
            buffer.push(i);
            time[i] = 0;
        }
    }
    while (!buffer.empty()) {
        int front = buffer.front();
        buffer.pop();
        vnum++;
        for (auto& e : graph[front]) {
            int v = e.to;
            int w = e.weight;
            degree[v]--;
            int tmp = time[front] + w;
            if (tmp > time[v]) {
                time[v] = tmp;
            }
            if (degree[v] == 0) {
                buffer.push(v);
                //ans += w;

            }
        }
    }
    if (vnum == n) {
        for (int i = 0; i < n; i++) {
            ans = max(ans, time[i]);
        }
        cout << ans;
    }
    else {
        cout << "Impossible";
    }
    //
}
```
## 2.1
```c
#include<iostream>
#include<vector>
#include<stack>

using namespace std;


int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	//
	int n; int m; int k;
	cin >> n; cin >> m; cin >> k;
	for (int kk = 0; kk < k; kk++) {
		//
		stack<int> huojia;
		huojia.push(10000);
		int need = 1;
		int cap = 1;
		int flag = 1;
		vector<int> arr(n, 0);
		for (int i = 0; i < n; i++) {
			cin >> arr[i];
		}
		for (int i = 0; i < n; i++) {
			while (true) {
				if (huojia.top() != need) {
					break;
				}
				huojia.pop();
				need++;
				cap--;
			}
			int num = arr[i];
			if (num == need) {
				need++;
				continue;
			}
			else {
				if (cap > m) {
					flag = 0;
					goto loop;
				}
				else {
					cap++;
					huojia.push(num);
				}
			}
		}
		while (true) {
			if (huojia.top() != need) {
				break;
			}
			huojia.pop();
			need++;
			cap--;
		}
		if (need != n + 1) {
			flag = 0;
		}
	loop:
		if (flag == 0) {
			cout << " no";
		}
		else {
			cout << "yes";
		}
	}
	//
}
```

## 6.0 非常经典的dfs bfs模板

## 6.4六度空间bfs
```cpp
void bfs(vector<vector<int>>& graph, int root, vector<bool>& visited, vector<int>& S,int flag) {
	visited[root] = true;
	queue<int> buffer;
	buffer.push(root);
	while (!buffer.empty()) {
		flag++;
		if (flag > 7) {
			break;
		}
		for (int i = 0; i < buffer.size(); i++) {
			int front = buffer.front();
			buffer.pop();
			//to S集合
			S.push_back(front);
			for (auto& e : graph[front]) {
				if (visited[e]) {
					continue;
				}
				visited[e] = true;
				buffer.push(e);
			}
		}
		
	}
}

int main() {
	cin.tie(nullptr);
	ios::sync_with_stdio(false);
	//
	int n, e; cin >> n >> e;
	vector<vector<int>> graph(n, vector<int>(0));
	for (int i = 0; i < e; i++)
	{
		int from; int to;
		cin >> from >> to;
		from--;
		to--;
		graph[from].push_back(to);
		graph[to].push_back(from);

	}
	for (int i = 0; i < n; i++) {
		int flag = 0;
		vector<bool> visited(n, false);
		vector<int> S(0);
		bfs(graph, i, visited, S,flag);
		cout << S.size()<<" ";
	}

	//
}
```