# 后序遍历中序风格改写

## 🧑‍💻 User

中序遍历class Solution {
 public List<Integer> inorderTraversal(TreeNode root) {
 List<Integer> ans = new ArrayList<>();
 ArrayDeque<TreeNode> cache = new ArrayDeque<>();
 TreeNode p=root;
 while (true){
 //终止条件
 if(cache.isEmpty() && p==null){
 return ans;
 }
 //模拟recur_tree
 if(p!=null){
 cache.push(p);
 p=p.left;
 }else{
 //这里return的箭头是虚线,虚返回但是返回到了pop右孩子
 TreeNode tmp = cache.pop();
 ans.add(tmp.val);
 p=tmp.right;
 }
 }
 }
}

后序遍历:	public static List<Integer> postorderTraversalOneStack(TreeNode h) {
List<Integer> ans = new ArrayList<>();
if (h == null) return ans;
Stack<TreeNode> stack = new Stack<>();
stack.push(h);
while (!stack.isEmpty()) {
				TreeNode cur = stack.peek();
				if (cur.left != null && h != cur.left && h != cur.right) {
					stack.push(cur.left);
				} else if (cur.right != null && h != cur.right) {
					stack.push(cur.right);
				} else {
					ans.add(cur.val);
					h = stack.pop();
				}
}

}

中序遍历用了一个p指针遍历二叉树,后序遍历使用栈顶遍历二叉树 ,能不能按照中序遍历的方法改写后序遍历

---
## 🤖 Assistant

好问题 👍
你观察得很细致：

- **中序遍历**（迭代法）之所以能用一个指针 `p` 一直往左压栈，弹栈时访问根，再转到右子树，是因为访问顺序是 **左 → 根 → 右**。
- **后序遍历**是 **左 → 右 → 根**。难点就在于：访问根要在左右子树之后。

我们希望像中序一样，用一个指针 `p` 来遍历，而不是靠「栈顶元素 + h 标记」那种写法。

---

## 方法一：类似中序的“指针前进+栈”的后序遍历

核心思路：
1. 用一个栈，指针 `p` 初始指向根。
2. 不停往左走，把所有左孩子入栈。
3. 但 **不能一弹栈就访问**，因为要先确认右子树是否已经处理过。
4. 所以需要一个 **上一次访问的节点 `lastVisited`**。

伪代码：

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    ArrayDeque<TreeNode> stack = new ArrayDeque<>();
    TreeNode p = root, lastVisited = null;
    while (p != null || !stack.isEmpty()) {
        if (p != null) {
            stack.push(p);
            p = p.left;        // 一直往左
        } else {
            TreeNode node = stack.peek();
            if (node.right != null && lastVisited != node.right) {
                // 如果有右子树，而且还没访问过，则转向右子树
                p = node.right;
            } else {
                // 否则就可以访问该节点
                ans.add(node.val);
                lastVisited = stack.pop();
            }
        }
    }
    return ans;
}
```

---

## 思路对比
- **中序遍历**：栈顶弹出后立刻访问自己，并转向右子树。
- **后序遍历**：栈顶弹出前，要确保右子树已经访问过（用 `lastVisited` 判断），否则就转向右子树。

所以完全可以“按照中序遍历的写法”来改造，只需多一个 `lastVisited` 的状态即可。

---

✅ 总结：
- 你想的没错 —— 后序遍历也能用“中序那种 `p` 指针”版本来写。
- 关键点：判断右子树是否访问过，用 `lastVisited` 记录。

---

要不要我也帮你写出一个**前序遍历**用相同“p 指针”风格的代码？这样三种遍历就完全对齐成一个套路。

---
## 🧑‍💻 User

这种遍历类似于模拟递归的过程,当cur.left != null && h != cur.left && h != cur.right,满足这个条件的时候,p指针才移动过去,没有像递归一样每个节点访问3次这个方法叫什么

---
## 🤖 Assistant

好问题 👍，你说得很对。我们来梳理一下几种常见的「树的迭代遍历」写法：

---

### 🌳 1. **递归遍历（直观写法）**
递归的时候，每个节点实际上会被「压栈」3 次（函数激活记录）：
- 第一次遇到这个节点（准备走左子树），
- 第二次回到这个节点（准备走右子树），
- 第三次回到这个节点（左右子树都处理完，真正退出）。

所以递归其实是 **「每个节点等价访问 3 次」** 的天然框架。

---

### 🌳 2. **显式模拟递归（节点访问三次法）**
有一些迭代写法，会在栈里保存 `(节点, 状态位)`，表示第几次回到这个节点。这样相当于按递归的那三次访问来模拟 —— 这种就是所谓的 **三次访问法 / 状态机模拟递归**。

---

### 🌳 3. **指针模拟法（p 指针 + lastVisited）**
你在中序里写的这种：
```java
while (p != null || !stack.isEmpty()) {
    if (p != null) { ... } else { ... }
}
```
这种写法的思路是：
- 用 `p` 指针负责「推进」，一条道往下走（通常是先左子树）；
- 用 `栈` 来记录返回路径；
- 用 `lastVisited` 来记录右子树是否访问过，避免「必须三次访问」；
- **特点：每个节点只真正出栈一次，访问一次**，避免显式三次模拟。

📌 这种方法在教材、论文、算法书里通常叫做：
- **迭代遍历（Iterative Traversal with Stack and Pointer）**，
- 或叫 **单栈迭代 + 标记法**，
- 有时也被习惯称为 **非递归遍历（非三次模拟写法）**。

---

### 🌳 4. **你提到的那种 `h != cur.left && h != cur.right` 的写法**
这种其实是 **利用“上一个访问的节点 h”来判断当前栈顶该不该继续下探**。
它本质上就是「单栈模拟 + 上次访问位置标记」的套路，和上面 `lastVisited` 思路一致，只是不是用 `p` 指针，而是固定盯着 `stack.peek()` 判断。

---

✅ **总结**
- 「每个节点访问三次」：叫 **三次访问法 / 模拟递归法 / 状态机法**。
- 「用指针前进 + lastVisited 状态」：叫 **单栈迭代法（Iterative Traversal with Stack and Pointer）**，或者俗称 **p 指针迭代法**。

---

要不要我给你画一张「三次模拟递归法」和「单栈指针法」的框架对比图？这样你一下子会看清楚它们的差别。
