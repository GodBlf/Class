# ====================================================================================================================================== 递归相关

# 递归题目
- recur.subset recover prune global

## [只用递归逆序栈](左肾自造题)
- recur.subset
### subset分析
- 返回栈底元素的算子
io:返回栈底元素 stack:void
f(n)={
    return poll if n==1  //leaf

    poll+g(n-1)+poll
}
g=f
- 逆序栈算子
stack:逆序栈 io:void
f(n)={
    return if n==1  //leaf

    返回栈底元素+g(n-1)+push
}
```java
package class038;

import java.util.Stack;

// 用递归函数逆序栈
public class Code05_ReverseStackWithRecursive {

    public static void reverse(Stack<Integer> stack) {
        if (stack.isEmpty()) {
            return;
        }
        int num = bottomOut(stack);
        reverse(stack);
        stack.push(num);
    }

    // 栈底元素移除掉，上面的元素盖下来
    // 返回移除掉的栈底元素
    public static int bottomOut(Stack<Integer> stack) {
        int ans = stack.pop();
        if (stack.isEmpty()) {
            return ans;
        } else {
            int last = bottomOut(stack);
            stack.push(ans);
            return last;
        }
    }

    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(5);
        reverse(stack);
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }

}

```

## [汉诺塔问题](简简单单的)
### subset分析
stack:打印n  a->c的路径 io:void
f(n)={
    sout(a,c) if n==1; //leaf

    g(n-1)+g(1)+g(n-1)
}
g=f
```java
class Solution{
    public static void dfs(int n,String a,String b,String c){
        if(n==1){
            System.out.println(a+"->"+c);
            return;
        }
        dfs(n-1,a,c,b);
        dfs(1,a,b,c);
        dfs(n-1,b,a,c);
        return;
    }
}
```


## [同时运行n台电脑最长时间](https://leetcode.cn/problems/maximum-running-time-of-n-computers)
- recur.subset
f(n)={
    sum/n
    g(n-1)
}
g=f

- 理论连续可供电时间为sum/n 如果遍历电池大于sum/n 那么就让他自己供一台电脑
转化为subset 子问题n-1台电脑和剩下的电池进行供电,
直到遍历电池<=sum/n 为0向量

```java
class Solution {
    public long maxRunTime(int n, int[] batteries) {
        Arrays.sort(batteries);
        long sum = 0;
        for (int b : batteries) {
            sum += b;
        }
        return dfs(n,batteries.length-1,batteries,sum);
    }
    public static long dfs(int n,int p,int[] arr,long sum){
        int  cur=arr[p];
        long junzhi=sum/n;
        if(junzhi<arr[p]){
            return dfs(n-1,p-1,arr,sum-cur);
        }
        return junzhi;
    }
}
```

- 迭代优化递归
```java
class Solution {
    public long maxRunTime(int n, int[] batteries) {
        Arrays.sort(batteries);
        long sum = 0;
        for (int b : batteries) {
            sum += b;
        }
        for (int i = batteries.length - 1; ; i--) {
            if (batteries[i] <= sum / n) {
                return sum / n;
            }
            sum -= batteries[i];
            n--;
        }
    }
}
```

## [至少有k个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)
- recur.subset map_container
- map容器设计成数组的形式比hashmap快非常多
- 这里是java里的split搭配正则表达式首次使用,正则表达式里的[]表示从集合中任意选取字符做分割点
- subset分析
f(s)={
    0 if s中字符都小于k
    max(g(s1),g(s2),...)  这里的si是将s中小于k的字符做分割点分割出来的字符串
}
g=f
```java
class Solution {
    public int longestSubstring(String s, int k) {
        return dfs(s,k);
    }
    public static int dfs(String s,int k){
        //小于k直接返回
        if(s.length()<k){
            return 0;
        }
        HashMap<Character,Integer> map=new HashMap<>();
        for(int i=0;i<s.length();i++) {
            char ch = s.charAt(i);
            if (map.containsKey(ch)) {
                map.put(ch, map.get(ch) + 1);
            } else {
                map.put(ch, 1);
            }
        }
        //两个标记控制全<k 和 全>=k
        boolean flag1=true;
        boolean flag2=true;
        String delim="[";
        for (Map.Entry<Character, Integer> sp : map.entrySet()) {
            if(sp.getValue()<k){
                flag1=false;
                //正则表达式
                delim=delim+""+sp.getKey();
                continue;
            }
            flag2=false;
        }
        //如果全<k直接return0;
        if(flag2){
         return 0;
        }
        //如果 全>=k直接return
        if(flag1){
            return s.length();
        }
        delim=delim+"]";
        String[] splits = s.split(delim);
        int ans=0;
        //subset
        for(int i=0;i<splits.length;i++){
            ans=Math.max(ans,dfs(splits[i],k));
        }
        return ans;
    }
}
```

# 括号嵌套类递归题目
## [括号嵌套计算器]()
```java

```

## [嵌套字符串解码](https://leetcode.cn/problems/decode-string/)


```java
class Solution {
    public String decodeString(String s) {
        str="";
        l=0;
        str=s+"]";
        return dfs(1);
    }
    public static String str;
    public static int l=0;
    public static String dfs(int n){
        StringBuilder stringBuilder = new StringBuilder();
        int cur=0;
        while(str.charAt(l)!=']'){
            if(str.charAt(l)>='0' && str.charAt(l)<='9'){
                cur=cur*10+(str.charAt(l)-'0');
                l++;
            }else if(str.charAt(l)=='['){
                l++;
                stringBuilder.append(dfs(cur));
                cur=0;
            }else{
                stringBuilder.append(str.charAt(l));
                l++;
            }
        }
        if(n==1){
            l++;
            return stringBuilder.toString();
        }else{
            StringBuilder ans = new StringBuilder();
            for(int i=0;i<n;i++){
                ans.append(stringBuilder.toString());
            }
            l++;
            return ans.toString();
        }
    }
}
```

# prune recover-memo_p_container  剪枝,带路径恢复的递归问题
- prune:非零向量提前通过判断转成0向量
- recover:退回某个节点,memo也要恢复到这个节点的状态
## [n皇后](https://leetcode.cn/problems/n-queens-ii/description/)
- json:recur prune recover 
### subset分析
- io:返回填n行皇后的种类数
- f(n)={
    return 0 if n==0 //leaf

    n*g(n-1) 填第n行每一列时对应填n-1行的种类数
}
g=f

### 剪枝版本
- f(n)={
    return 0 if n==0 //leaf
 
    g(n-1)+...~~g(n-1)~~...g(n-1)  //prune
}
g=f
- prune : 通过记忆之前的路径开g栈时提前剪掉,判断标准为同一列 或者同一斜线

```java
import java.util.Arrays;

class Solution {
    public int totalNQueens(int n) {
        int[] path = new int[n];
        Arrays.fill(path,-1);
        return dfs(path,0,n);
    }

    public static int dfs(int[] path,int i,int n){
        if(i==n){
            return 1;
        }
        int ans=0;
        for(int j=0;j<n;j++){
            if(check(path,i,j)){
                path[i]=j;
                ans+=dfs(path,i+1,n);
                path[i]=-1; //recover
            }
        }
        return ans;
    }

    public static boolean check(int[] path,int i,int j){
        for(int k=0;k<i;k++){
            if(j==path[k]){
                return false;
            }
            if(Math.abs(i-k)==Math.abs(j-path[k])){
                return false;
            }
        }
        return true;
    }

}
```
### 剪枝位图版本(状态压缩)
- recur prune recover bitmap
```java
class Solution {
    public int totalNQueens(int n) {
        int e=(1<<n)-1;
        return dfs(0,n,0,0,0,e);
    }//
    //col left right分别是填在某列时剩下列不能填的位置
    public static int dfs(int i,int n,int col,int left,int right,int e){
        if(i==n){
            return 1;
        }
        int ans=0;
        int ban=col | left | right;
        //遍历能填的位置,直接剪掉不能填的位置
        //取反再*e再用lowbit方便取出原bitmap中的0
        int can=e&(~ban);
        while(can!=0){
            int lowbit = can&(-can);
            ans+=dfs(i+1,n,col+lowbit,(left+lowbit)<<1,(right+lowbit)>>1,e);
            can-=lowbit;
        }
        return ans;
    }
}
```

## 感染问题(洪水填充问题)

## [岛屿数量](https://leetcode.cn/problems/number-of-islands/)
- subset分析
io:void stack:感染以ij为起点的所有连起来的1岛屿
f(i,j)={
    return if i,j是0||超出边界||已经感染过了 //leaf

    感染i,j+g(ij上)+g(ij下)+g(ij左)+g(ij右)
}
g=f
- prune: 感染的做标记 提前判断有没有感染直接return变成0向量
```java
class Solution {
    public int numIslands(char[][] grid) {
        int ans=0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]=='1'){
                    ans++;
                    dfs(grid,i,j);
                }
            }
        }
        return ans;
    }

    public static void dfs(char[][]grid,int i,int j){
        //注意这里是'1'不是1睇错
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!='1'){
            return;
        }
        
        grid[i][j]='2';
        dfs(grid , i,j+1);
        dfs(grid , i,j-1);
        dfs(grid , i+1,j);
        dfs(grid , i-1,j);
    }
}
```

## [被围绕的区域](https://leetcode.cn/problems/surrounded-regions/description/)
- 上一题岛屿数量的变式
- 从边缘开始找起,对边缘的o进行感染,感染成f,中间的o不影响,然后中间的o遍历改成x,再把感染的f改回o就可以
```java
class Solution {
    public void solve(char[][] board) {
        for(int j=0;j<board[0].length;j++){
            if(board[0][j]=='O'){
                dfs(board,0,j);
            }
        }
        for(int j=0;j<board[0].length;j++){
            if(board[board.length-1][j]=='O'){
                dfs(board,board.length-1,j);
            }
        }
        for(int i=0;i<board.length;i++){
            if(board[i][0]=='O'){
                dfs(board,i,0);
            }
        }
        for(int i=0;i<board.length;i++){
            if(board[i][board[0].length-1]=='O'){
                dfs(board,i,board[0].length-1);
            }
        }
        for(int i=0;i<board.length;i++){
            for (int j=0;j<board[0].length;j++){
                if(board[i][j]=='O'){
                    board[i][j]='X';
                }
                if(board[i][j]=='F'){
                    board[i][j]='O';
                }
            }
        }
        return;
    }

    public static void dfs(char[][] board,int i,int j){
        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]=='X') return;
        //prune
        if(board[i][j]=='F') return;
        board[i][j]='F';
        dfs(board,i+1,j);
        dfs(board,i-1,j);
        dfs(board,i,j+1);
        dfs(board,i,j-1);
    }
}
```

## [最大人工岛](https://leetcode.cn/problems/making-a-large-island/)
- 上上题岛屿数量的变式
- 先感染每座岛屿并为每座岛屿起名,把岛屿对应的数量记录到map里可以dfs时候顺便返回记录,也可以重新遍历记录
- 遍历所有0,将上下左右的岛屿数量加起来在+1,注意要去重,最后max比较出最大的
```java
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

class Solution {
    public int largestIsland(int[][] grid) {
        int cnt=2;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    dfs(grid,i,j,cnt);
                    cnt++;
                }
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        //sentry
        map.put(0,0);
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]!=0){
                    if(map.containsKey(grid[i][j])){
                        map.put(grid[i][j],map.get(grid[i][j])+1);
                    }else{
                        map.put(grid[i][j],1);
                    }
                }
            }
        }
        //找出岛屿中数量最大的
        int max=0;
        for (Map.Entry<Integer, Integer> e : map.entrySet()) {
            max=Math.max(max,e.getValue());
        }

        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0){
                    //memo_p_container 去重防止重复记录
                    HashSet<Integer> set = new HashSet<>();
                    if(i>0){
                        set.add(grid[i-1][j]);
                    }
                    if(i<grid.length-1){
                        set.add(grid[i+1][j]);
                    }
                    if(j>0){
                        set.add(grid[i][j-1]);
                    }
                    if(j<grid[0].length-1){
                        set.add(grid[i][j+1]);
                    }
                    int sum=0;
                    for (Integer sp : set) {
                        sum+=map.get(sp);
                    }
                    max=Math.max(max,sum+1);
                }
            }
        }
        return max;
    }
    public void dfs(int[][] grid,int i,int j,int cnt){
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=1){
            return;
        }
        grid[i][j]=cnt;
        dfs(grid,i,j+1,cnt);
        dfs(grid,i,j-1,cnt);
        dfs(grid,i+1,j,cnt);
        dfs(grid,i-1,j,cnt);
    }
}
```

## [打砖块](https://leetcode.cn/problems/bricks-falling-when-hit)
- reverse.time_return
- 依然是上上上题的变式,卧槽能变出多少花活来阿
- 这题的dfs是有io的 io:返回感染的数量
- 时光倒流,用2表示有粘性的砖块
先复原顶层砖块,再一步步到访复原
```java
class Solution {
    //防止参数过多设置全局变量
    public static int n;
    public static int m;
    public static int[][] g;
    public int[] hitBricks(int[][] grid, int[][] hits) {
        int[] ans = new int[hits.length];
        n=grid.length;m=grid[0].length;g=grid;
        for (int[] hit : hits) {
            g[hit[0]][hit[1]]-=1;
        }
        for(int j=0;j<m;j++){
            dfs(0,j);
        }
        //recover 时光倒流,从尾到头一步步还原
        for (int i = hits.length - 1; i >= 0; i--) {
            int x=hits[i][0];
            int y=hits[i][1];
            g[x][y]++;
            if(isDfs(x,y)){
                ans[i]=dfs(x,y)-1;
            }else{
                ans[i]=0;
            }
        }
        return ans;
    }

    public static boolean isDfs(int i,int j){
        //state-filter 枚举所有状态一共3^4所以进过滤true的选项
        if(g[i][j]<=0) return false;
        if(i==0 || g[i-1][j]==2) return true;
        if(i<n-1 && g[i+1][j]==2 ) return true;
        if(j>0 && g[i][j-1]==2) return true;
        if(j<m-1 && g[i][j+1]==2) return true;
        return false;
    }

    public static int dfs(int i,int j){
        if(i<0 || j<0 || i>=n || j>=m || g[i][j]!=1){
            return 0;
        }
        g[i][j]=2;
        int ans=0;
        ans+=dfs(i+1,j);
        ans+=dfs(i-1,j);
        ans+=dfs(i,j+1);
        ans+=dfs(i,j-1);
        //io:返回感染的数量
        return ans+1;
    }
}
```

# 多维递归和多返回值递归题目
- 多维递归就是参数有若干个,子集是order,通过3维空间函数思考

## [二叉树打家劫舍](https://leetcode.cn/problems/house-robber-iii/)
- recur.subset.multidim or .multi_return 
- 通过多返回值降维优化二维的递归问题将2个order转化为2个返回值1个参数
- 也可以看作本质就是一个多返回值得算子
递归多返回值问题,
f(root)={
    return 0,0 if null
    return1: g(root.left).return1+g(root.right).return2
    return2: max(g(root.l).return1,.return2 )+max(g(root.r).return1,.return2)
    return
}
g=f

```java
class Solution {
    public int rob(TreeNode root) {
        int ans1=dfs2(root,0);
        int ans2=dfs2(root,1);
        return Math.max(ans1,ans2);
    }
    public static int dfs2(TreeNode sp,int state){
        if(sp==null){
            return 0;
        }
        int l0=dfs2(sp.left,0);
        int l1=dfs2(sp.left,1);
        int r0=dfs2(sp.right,0);
        int r1=dfs2(sp.right,1);
        if(state==0){
             return Math.max(l0,l1)+Math.max(r0,r1);
        }
        return l0+r0+ sp.val;
    }
}
//可加map优化为记忆化搜索
```

- 多返回值优化
```java
class Solution {
    public int rob(TreeNode root) {
        int[] ans = dfs(root);
        return Math.max(ans[0],ans[1]);
    }
    public static int[] dfs(TreeNode sp){
        if(sp==null){
            return new int[]{0,0};
        }
        int[] l = dfs(sp.left);
        int[] r = dfs(sp.right);
        int[] ans = new int[2];
        ans[0]=l[1]+r[1]+sp.val;
        ans[1]=Math.max(l[0],l[1])+Math.max(r[0],r[1]);
        return ans;
    }
}
//这里的dfs是求每个节点的两个值
```

## [二叉树直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
- recur.subset.multidim or .multi_return
- 设计成多维递归优化为多返回值
- 返回到节点左树得最大值和右树的最大值

```java
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        max=0;
        dfs(root);
        return max-1;
    }
    public static int max;
    public static int[] dfs(TreeNode sp){
        if(sp==null){
            return new int[]{0,0};
        }
        int[] l=dfs(sp.left);
        int[] r=dfs(sp.right);
        int lmax=Math.max(l[0],l[1]);
        int rmax=Math.max(r[0],r[1]);
        int ans=lmax+rmax+1;
        max=Math.max(ans,max);
        return new int[]{lmax+1,rmax+1};

    }
}
```



# ====================================================================================================================================== 离散函数和动态规划
- 用数组模拟算子,将索引映射的算法
- 动态规划可以看作递归树的逆从leaf到root的遍历,递归可改成dp

# 前缀和积分
```json
{
    "解决查询区间和问题":null,//前缀和解决查询区间和问题,实现原理是先积分,再积分函数相减得到区间和,∫f(b)-∫f(a) 得到a,b区间和
    "积分数组":"doo.∫∑+.subset sentry"
    //doo.subset i处积分值有i-1和arr[i]获得
    //积分数组设置一个sum(0,)的sentry,因为经常需要查询[0,n]区间和问题方便查询
}
```
```java
class NumArray {
    public int[] sum;
    public NumArray(int[] nums) {
        //0sentry
        sum=new int[nums.length+1];
        for(int i=1;i<=nums.length;i++){
            //doo.subset
            sum[i]=sum[i-1]+nums[i-1];
        }
    }

    public int sumRange(int left, int right) {
        return sum[right+1]-sum[left];
    }
}

```

## 习题
 
### [累加和为k的最长子串](https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5)
- 典中典区间查询问题
- 前缀和 map_container.map_arr 
```java
public class Main {
    public static int[] sum=new int[100004];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        //
        in.nextToken();int n=(int)in.nval;in.nextToken();int tg=(int)in.nval;
        //用map容器记忆前缀和和索引方便快速查询
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,0);
        //前缀和区间查询问题设置一个sum(0,0)sentry,方便查询0,n区间的sum
        for(int i=1;i<=n;i++){
            in.nextToken();
            sum[i]=sum[i-1]+(int)in.nval;

            if(!map.containsKey(sum[i])){
               map.put(sum[i],i);
            }
        }
        int ans=-1;
        for(int i=1;i<=n;i++){
            int cha=sum[i]-tg;
            if(map.containsKey(cha)){
                //注意这里去重,参见滑动窗口,子串以右边界为基准,遍历全子串
                //注意这里是小于防止长度为0的空子串
                if(map.get(cha)<i) {
                    ans = Math.max(i - map.get(cha), ans);
                }
            }
        }
        out.println(ans);
        //
        out.flush();
        out.close();
        br.close();
    }

}

```

### [正负数量相等的最长子串](https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb)
- data_mapping 数据映射 前缀和
- 将正数映射到1,负数映射到-1,0映射到0 正数数量 负数数量 这样做前缀和就可以计算出某个区间正数和负数的数量之差,再进行区间查询
```java
public class Main {
    public static int[] sum=new int[100004];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        //
        in.nextToken();int n=(int) in.nval;
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=1;i<=n;i++){
            in.nextToken();
            int tmp=(int)in.nval;
            int num=0;
            if(tmp>0){
                num=1;
            }else if(tmp<0){
                num=-1;
            }else{
                num=0;
            }
            sum[i]=num+sum[i-1];
            if(!map.containsKey(sum[i])){
                map.put(sum[i],i);
            }
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            if(map.containsKey(sum[i])){
                if(map.get(sum[i])<i){
                    ans= Math.max(ans,i-map.get(sum[i]));
                }
            }
        }
        out.println(ans);
        //
        out.flush();
        out.close();
        br.close();
    }

}

```

### [累加和为k的子串数量](https://leetcode.cn/problems/subarray-sum-equals-k/)
- 前缀和 nobacktracking_pointer 不回退指针既优化了sum数组空间又解决了顺序问题防止出现长度为0子串的情况,喵!
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> map=new HashMap<>();
        int ans=0;
        map.put(0,1);
        int sum=0;
        for(int i=1;i<=nums.length;i++){
            sum+=nums[i-1];
            int cha=sum-k;
            if(map.containsKey(cha)){
                ans+=map.get(cha);
            }    
            //注意这里应该先寻找,在加入map里,因为有可能k=0;出现长度为0子串的情况
            if(map.containsKey(sum)){
                map.put(sum,map.get(sum)+1);
            }else{
                map.put(sum,1);
            }
        }
        return ans;
    }
}
```

### [良好上班的最长时间](https://leetcode.cn/problems/longest-well-performing-interval/)
- 前缀和 data_mapping doo.continue_oo nobacktracking_pointer map_container
- 将>8映射到1 <=8映射到-1 
- 最后原数组都是1,-1 所以生成的积分sum数组从0开始是"连续"的每次索引增加1 sum函数值仅能变化+1 -1,所以sum函数满足连续函数的介值定理
- 因为每次遍历要寻找之前的所以用nobacktracking_pointer 不回退指针既优化了sum数组空间又解决了不访问之后数组的顺序问题
- 遍历sum 到i如果sum[i]=-3  那么仅需要找到i之前-4所在的最左边的位置就是最长的
- 反证法证明,如果-4左边还有-5之类的,那么根据连续函数介值定理,原点值是0,从原点到-5这个点,sum函数绝对能取到0~-5任何值,所以再-5左边仍然有-4;
- 用map记住值对应的索引遍历即可
```java
class Solution {
    public int longestWPI(int[] hours) {
        int ans=0;
        int sum=0;
        HashMap<Integer,Integer> map=new HashMap<>();
        map.put(0,-1);
        for(int i=0;i<hours.length;i++){
            int num=0;
            if(hours[i]>8){
                num=1;
            }else{
                num=-1;
            }
            sum+=num;
            if(sum>0){
                ans=i+1;
                continue;
            }
            int cha=sum-1;
            if(map.containsKey(cha)){
                ans=Math.max(ans,(i-map.get(cha)));
            }

            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return ans;
    }
}
```


# 差分微分


# doo.prefix

## 题目
### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
```json
{
    "前缀max后缀max":"discrete_oo.prefix+.subset",
    "指针优化前后缀函数":"reduce_dim nobacktracking_pointer"
}
```
- 对于i位置能够接雨水的数量为不包含他的前缀最大值和不包含他的后缀最大值的min,min-i就是i位置接的雨水数量
- 所以构建数组所有位置的前缀后缀函数,再一个一个遍历
```java
public static int trap1(int[] nums) {
        int n = nums.length;
        int[] lmax = new int[n];
        int[] rmax = new int[n];
        lmax[0] = nums[0];
        // 0~i范围上的最大值，记录在lmax[i]
        for (int i = 1; i < n; i++) {
            lmax[i] = Math.max(lmax[i - 1], nums[i]);
        }
        rmax[n - 1] = nums[n - 1];
        // i~n-1范围上的最大值，记录在rmax[i]
        for (int i = n - 2; i >= 0; i--) {
            rmax[i] = Math.max(rmax[i + 1], nums[i]);
        }
        int ans = 0;
        //   x              x
        //   0 1 2 3...n-2 n-1
        for (int i = 1; i < n - 1; i++) {
            ans += Math.max(0, Math.min(lmax[i - 1], rmax[i + 1]) - nums[i]);
        }
        return ans;
    }
```

- reduce_dim优化
- 可以将前缀函数构建的数组函数用一个指针代替降维优化,前缀后缀直接用两个不回退指针往中间缩
- 左指针左侧函数是确定的,右指针右侧函数是确定的所以取左右最小值即可
```java
class Solution {
    public int trap(int[] height) {
        int l=1;int r=height.length-2;int lmax=0;int rmax=0;
        int ans=0;
        while(l<=r){
            lmax=Math.max(lmax,height[l-1]);
            rmax=Math.max(rmax,height[r+1]);
            //lmax和rmax相等的时候不能l++和r--因为如果l==r,那么就会重复计算
            if(lmax<=rmax){
                int tmp=lmax-height[l];
                if(tmp>0){
                    ans+=tmp;
                }
                l++;
            }else {
                int tmp=rmax-height[r];
                if(tmp>0){
                    ans+=tmp;
                }
                r--;
            }
        }
        return ans;
    }
}
```


## KMP
https://www.bilibili.com/video/BV1Er421K7kF/
https://oi-wiki.org/string/kmp/
```json
{
    "前缀算子π":"symmetry discrete_oo.prefix",
    "π算子幂":"vector_space.pow_basis",
    // "Π算子幂的边界判断":"vars_hubs state_pointer"
    //因为这俩很基础但在kmp体现的淋漓尽致所以指出来
}
```
### 前缀算子π


### symmetry discrete_oo.prefix
![alt text](image-6.png)
![alt text](image-7.png)
```go
π(i-1)+1=π(i)
ππ(i-1)+1=π(i)
π^3(i-1)+1=π(i)
...
π^n(i-1)+1=π(i)
//终止条件是π^n==0 || π^n(-1)+1==π(i)
//以1为索引 以0就one_short
```
```java
//以0为索引
class Solution {
    public int strStr(String haystack, String needle) {
        int ans=needle.length();
        StringBuilder sb = new StringBuilder();
        sb.append(needle);sb.append('#');sb.append(haystack);
        int[] pi = new int[sb.length()];
        pi[0]=0;
        for(int i=1;i<pi.length;i++){
            //sp是state_pointer 类似于int i while{ i++}末尾状态更新
            int sp=pi[i-1];
            while(true){
                //vars_hubs 枚举边界状态
                if(sp==0 && sb.charAt(sp)==sb.charAt(i)){
                    pi[i]=1;
                    break;
                }else if(sp==0 && sb.charAt(sp)!=sb.charAt(i)){
                    pi[i]=0;
                    break;
                }else if(sp!=0 && sb.charAt(sp)==sb.charAt(i)){
                    pi[i]=sp+1;
                    break;
                }else{
                    sp=pi[sp-1];
                }
            }
            if(pi[i]==ans){
                return i-2*ans;
            }
        }
        return -1;
    }
}

//以1为索引
class Solution {
    public int strStr(String haystack, String needle) {
        int ans=needle.length();
        StringBuilder sb = new StringBuilder();
        sb.append(needle);sb.append('#');sb.append(haystack);
        int[] pi = new int[sb.length()];
        pi[0]=0;
        for(int i=1;i<pi.length;i++){
             //j是迭代指数 类似于int i while{ i++}末尾状态更新
            int j=pi[i-1];
            while(true){
                if(j==0 || sb.charAt(i)==sb.charAt(j)) break;
                j=pi[j-1];
            }
            if(sb.charAt(i)==sb.charAt(j)){
                pi[i]=j+1;
            }
            if(pi[i]==ans){
                return i-2*ans;
            }
        }
        return -1;
    }
}
```

# =================================================================== 动态规划
- 动态规划就是将递归转化为离散空间上的算子例如数组上二叉树上,所以任何动态规划都能转化成递归
- 递归的某个子集重复计算且每个节点在一个离散空间上就可以转化成动态规划
- dp=doo.subset=recur.subset+重叠子问题+离散空间
# 一维动态规划
## 典中典 fabbnoci 数列
算子dp,将索引i映射到i的斐波那契值 dp(i)=dp(i-1)+dp(i-2);
```java
public static int fabbnoci(int n){
    int[] dp=new int[n+1];
    dp[0]=1;dp[1]=1;
    for(int i=2;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
}
```
- 降维优化
```java
public static int fabbnoci(int n){
    int dp1=1;int dp2=1;
    int i=1;
    while(true){
        if(i==n) return dp2;
        int tmp=dp2;
        dp2=dp1+dp2;
        dp1=tmp;
        i++;
    }
}
```

## 习题
### [最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/)

