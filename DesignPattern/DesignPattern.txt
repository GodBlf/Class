# Hook
- 框架
you call library , framework call you
you call library function,framework call your function
框架是基于hook模式建立的

- 系统运行时执行注册的hook函数
```mermaid
graph LR
A(System)-->|call_back|B((Hook))
A-->|call_back|C((Hook))
A-->|call_back|D((....))
E(HookRegister)
B<-->E
C<-->E
D<-->E

```

- callback实现
gin框架路由仅注册传入回调函数,gin.run()路由请求方法再调用注册的回调函数,hook会传递一个框架参数方便hook函数和框架的通信

# Singleton 单例设计模式
- 设计global全局变量和initialize初始化函数,程序或者测试运行前加载initialize初始化全局变量和全局运行环境
- 单例设计模式和依赖注入这两个互为反,全局的工具性的变量设置为单例执行前初始化,其他需要用到的时候在注入是依赖注入

# midwear
## 接口
- 给具体的变量实现加一个中间层,这个中间层是函数的集合,调用变量仅能通过接口 
- 简化,从var operator tree角度思考面向接口编程和依赖注入
- type之类的struct interface type []int等都是反应变量的内部情况包含什么,方法就是对应的operator
父节点是接口,子节点是具体实现们
- interface是一个tree他链接这多个实现的变量,和其他变量不同仅是解耦

# DI
- 为什么需要依赖注入,全局变量无法实现接口的多态解耦功能需要嵌入字段实现di
- 具体实现变量用lazy global的方式实现懒全局变量,仅需要的时候再用sync.once设置为全局变量实现接口依赖注入,
- 需要设置为lazy global的就是依赖注入变量,不需要的就是变量包含,依赖注入的直接传参数里交给wire框架,变量包含自己赋值

详见wire




# FactoryPattern
- 自己不创建(new)管理对象交给工厂调用方法或者注解创建管理对象给你这个对象的使用权




#缓存Cache


