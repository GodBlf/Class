# goroutine
- tree
- go func : 在主线程节点下给这个函数栈分配一个子节点线程
树形结构考虑线程,go func在主线程节点分出一个子线程,子线程root下就是这个func函数

# 并发控制
### waitgroup
等待组的并发控制外移分离并发控制和业务逻辑
- 树形结构考虑线程,go func在主线程节点分出一个子线程,子线程root下就是这个func函数,控制外移就是在root和func之间加一个中间控制函数
- 匿名函数+defer实现并发控制外移
- 原本需要go f(wg *sync.WaitGroup){defer wg.done()}
wg仅起到flag标记函数返回没有的标记,所以抽离出来放在原函数和新线程root之间的中间件,
原函数返回的时候正好defer掉wg
- 因为golang支持闭包所以可以不用传wg这个参数
```go
main{
wg := &sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()
		chatsession.ChatStream(ctx, "讲解算法中的二分答案法")
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		chatsession.ChatStreamOut()
	}()
	wg.Wait()

}
```
记得wg.add一定要在主线程加,最后要wg.wait

# channel
- midwear
- 线程通信,make(chan int,16)
- <- chan int  chan int <-
- error传递到通道里,实现错误返回,另一个线程函数检测到<-chan元素包含错误就直接break return

# select
- ifelse变体 variable state choose
- 阻塞协程只到通道有货或者都无执行default
```go
select{
    case tmp:=<-ch1:
        //...
    case <-ch2:
        //...
    default:
        //通道皆无货执行
}
```
- 搭配context实现协程取消
```go
{
    go task1

    go task2

    go task3

    select{
        case: <-context.Done()
            logger.Error("time out",
            zap.Err(errors.NewError("time out")))
            return 
        case: <-ch1

        case: <-ch2

        case: <-ch3
    }
}
```

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // 创建一个 2 秒的超时 Context
    这些语句时间约等于0s
    ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
    defer cancel()

    resultCh := make(chan string, 1)

    //主要耗时任务开另一个协程运行
    go func() {
        // 模拟耗时操作（比如访问数据库/外部服务）
        time.Sleep(3 * time.Second)
        resultCh <- "done"
    }()
    //
    select {
    case res := <-resultCh:
        fmt.Fprintln(w, "result:", res)
    case <-ctx.Done():
        http.Error(w, "request timeout", http.StatusGatewayTimeout)
    }
}

```


#
websocket llm流式输出 grpc等的stream流
都可以视作一个chan stream.Recv()就是  <-chan 管道发出数据然后阻塞线程
for true{
    stream.Recv()
    if eof break
}
就是
for i := range chan